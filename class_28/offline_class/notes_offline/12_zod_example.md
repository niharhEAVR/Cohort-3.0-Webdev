# 1Ô∏è‚É£ **Imports**

```ts
import { z } from 'zod';
import express from "express";
```

* `zod` ‚Üí for **runtime schema validation** and **type inference**
* `express` ‚Üí web framework for Node.js

We are combining **runtime validation** (Zod) with **TypeScript type safety**.

---

# 2Ô∏è‚É£ **Express app setup**

```ts
const app = express();
app.use(express.json()); // Important for req.body
```

* Creates an Express server.
* `app.use(express.json())` is middleware that parses incoming JSON request bodies. Without it, `req.body` would be `undefined`.

---

# 3Ô∏è‚É£ **Zod schema definition**

```ts
const userProfileSchema = z.object({
  name: z.string().min(1, { message: "Name cannot be empty" }),
  email: z.string().email({ message: "Invalid email format" }),
  age: z.number().min(18, { message: "You must be at least 18 years old" }).optional(),
});
```

* `z.object({...})` ‚Üí defines a **schema for an object**
* `z.string().min(1)` ‚Üí must be a string of at least length 1
* `z.string().email()` ‚Üí must be a valid email
* `z.number().min(18).optional()` ‚Üí number ‚â• 18, optional field

**Key point:** This schema **works at runtime**, i.e., it can **check incoming JSON requests**.

---

# 4Ô∏è‚É£ **TypeScript inference with Zod**

```ts
type FinalUserSchema = z.infer<typeof userProfileSchema>;
```

* `z.infer<typeof userProfileSchema>` ‚Üí **TypeScript type inference**
* It **extracts the TypeScript type from the Zod schema** automatically.

This is powerful because:

```ts
type FinalUserSchema = {
  name: string;
  email: string;
  age?: number;
};
```

* `name` and `email` ‚Üí required strings
* `age` ‚Üí optional number
* ‚úÖ You don‚Äôt need to manually write this TypeScript type.
* Changes in the Zod schema automatically reflect in `FinalUserSchema` ‚Üí avoids duplication.

---

# 5Ô∏è‚É£ **Route handler with validation**

```ts
app.put("/user", (req, res) => {
  const result = userProfileSchema.safeParse(req.body);
```

* `safeParse(req.body)` ‚Üí validates the incoming JSON **at runtime**
* Returns:

```ts
{
  success: boolean;
  data?: FinalUserSchema;
  error?: ZodError;
}
```

* `success` ‚Üí true if validation passed
* `data` ‚Üí the validated and typed object
* `error` ‚Üí detailed validation errors if failed

---

# 6Ô∏è‚É£ **Handle validation errors**

```ts
if (!result.success) {
  return res.status(400).json({
    message: "User update error, provide valid data",
    errors: result.error.issues
  });
}
```

* If validation fails, we return **HTTP 400** with validation error details
* `result.error.issues` ‚Üí array of errors generated by Zod

---

# 7Ô∏è‚É£ **Use the validated data safely**

```ts
const updateBody: FinalUserSchema = result.data;
```

* Since `safeParse` passed, `result.data` is **guaranteed** to match the schema.

* We assign it to `updateBody` with **type safety** from TypeScript via `FinalUserSchema`

* ‚úÖ No TypeScript errors

* ‚úÖ Safe to use `updateBody.name`, `updateBody.email`, `updateBody.age`

---

# 8Ô∏è‚É£ **Responding to the client**

```ts
res.json({
  message: "User updated successfully",
  data: updateBody
});
```

* Sends back JSON response with validated data
* Demonstrates **type-safe runtime validation + TypeScript static typing**

---

# 9Ô∏è‚É£ **Start the server**

```ts
app.listen(3000, () => console.log("Server running on port 3000"));
```

* Starts Express on port 3000

---

# üîë **Key Concept ‚Äî `z.infer`**

* **Problem without `infer`:**
  You would need to write the type manually:

```ts
type FinalUserSchema = {
  name: string;
  email: string;
  age?: number;
};
```

* **Problem:** if the schema changes, you must remember to update the type manually.
* **Solution (`z.infer`)**: TypeScript automatically **infers the type from the Zod schema**:

```ts
type FinalUserSchema = z.infer<typeof userProfileSchema>;
```

* This ensures **runtime validation** and **compile-time type safety** are always in sync.

---

‚úÖ **Summary**

1. **Zod** validates **incoming data at runtime**
2. **z.infer** automatically creates the **TypeScript type** from the Zod schema
3. The route safely uses validated data, no need for manual type annotations
4. Combines **runtime validation + TypeScript static typing** seamlessly

---

If you want, I can draw a **diagram showing the flow**:

```
Incoming JSON ‚Üí Zod Schema ‚Üí safeParse ‚Üí TypeScript inferred type ‚Üí Express route
```

This makes it very easy to **visualize how z.infer works**.