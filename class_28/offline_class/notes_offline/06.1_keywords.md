# ğŸŸ¦ 1. **`keyof` â€” Get the keys of a type**

`keyof` takes a type and returns its **keys as a union of strings**.

### Example:

```ts
type User = {
  id: number;
  name: string;
  age: number;
};

type Keys = keyof User;
```

Now:

```ts
Keys === "id" | "name" | "age"
```

So this becomes useful when:

âœ” You want to restrict values to valid keys
âœ” Build generic utility types
âœ” Prevent wrong property names

---

### Practical Example

```ts
function getValue<T>(obj: T, key: keyof T) {
  return obj[key];
}

getValue({ id: 1, name: "Raj" }, "name"); // âœ”
getValue({ id: 1, name: "Raj" }, "email"); // âŒ error
```

---

# ğŸŸ© 2. **`in` â€” Loop through keys (Mapped Types)**

`in` is used **inside types** to create new types based on existing keys.

### Example:

```ts
type Optional<T> = {
  [K in keyof T]?: T[K];
};
```

Here:

* `keyof T` â†’ list of keys
* `K in keyof T` â†’ loop through each key
* `?` â†’ make it optional

This is how utility types like `Partial` are built.

---

### Example: Make all properties readonly

```ts
type MyReadonly<T> = {
  readonly [K in keyof T]: T[K];
};
```

---

# ğŸŸ¥ 3. **`extends` â€” Two Uses**

## **A) Generic constraint**

```ts
function log<T extends string>(value: T) {
  console.log(value);
}

log("hello");  // âœ”
log(123);      // âŒ error
```

Meaning:

> â€œT must be a string or a subtype of string.â€

---

## **B) Conditional types**

Syntax:

```ts
T extends U ? X : Y
```

Itâ€™s like an if-else **but inside types**.

---

### Example: Check if a type is a string

```ts
type IsString<T> = T extends string ? true : false;
```

Usage:

```ts
type A = IsString<string>;  // true
type B = IsString<number>;  // false
```

---

### Example: Remove `null`

```ts
type NotNull<T> = T extends null ? never : T;

type Result = NotNull<string | null>;
```

`Result` becomes:

```ts
string
```

---

# ğŸŸ§ 4. **`infer` â€” Extract a type from another type**

`infer` works ONLY inside conditional types.
It **captures** (extracts) a type from inside another type.

Think of it like:

> â€œTypeScript, please figure out the type and store it inside a variable.â€

---

### ğŸ“Œ Example: Extract the return type of a function

```ts
type ReturnTypeOf<T> =
  T extends (...args: any[]) => infer R ? R : never;
```

Here:

* `infer R` extracts the return type
* `R` becomes the return type of the function

Usage:

```ts
type R = ReturnTypeOf<() => number>;  
// R == number
```

---

### ğŸ“Œ Example: Extract array element type

```ts
type ElementType<T> =
  T extends (infer U)[] ? U : never;
```

Usage:

```ts
type A = ElementType<string[]>;  // string
type B = ElementType<number[]>;  // number
```

---

### ğŸ“Œ Example: Extract promise value

```ts
type UnwrapPromise<T> =
  T extends Promise<infer U> ? U : T;
```

Usage:

```ts
type A = UnwrapPromise<Promise<string>>; // string
type B = UnwrapPromise<number>;        // number (unchanged)
```

---

# ğŸ‰ Summary Table

| Concept                   | Meaning                           | Example               |         |
| ------------------------- | --------------------------------- | --------------------- | ------- |
| **keyof**                 | Get keys of a type                | `"id"                 | "name"` |
| **in**                    | Loop through keys in mapped types | `[K in keyof T]`      |         |
| **extends (generic)**     | Restrict a generic type           | `T extends string`    |         |
| **extends (conditional)** | If-else inside types              | `T extends U ? X : Y` |         |
| **infer**                 | Extract a type                    | `infer R`             |         |


---

# Dont understand anything, read this [click](./06.2_conditional_type.md)