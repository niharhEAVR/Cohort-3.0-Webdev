# âœ… The Type You Saw

```ts
type IsString<T> = T extends string ? true : false;
```

This is a **conditional type** in TypeScript.

---

# ğŸŸ¦ 1. What is a Conditional Type?

Itâ€™s basically **an if-else, but inside TypeScript types**.

Structure:

```ts
T extends U ? X : Y
```

Think of it like:

```
If T is a subtype of U then return X else return Y
```

---

# ğŸŸ© 2. Breaking it Down Step-by-Step

### `T extends string`

This is like asking:

> "Is T assignable to string?"

If yes â†’ choose the first value.
If no â†’ choose the second value.

### `? true : false`

This is the same as JavaScript ternary:

```js
condition ? resultIfTrue : resultIfFalse
```

---

# ğŸŸ§ 3. FULL Flow of Your Example

Letâ€™s plug in a type:

```ts
type A = IsString<string>;
```

Now replace `T` with `string`:

```
string extends string ? true : false
```

This is true.
So:

```ts
type A = true;
```

---

Another example:

```ts
type B = IsString<number>;
```

Replace `T` with `number`:

```
number extends string ? true : false
```

This is false.

So:

```ts
type B = false;
```

---

# ğŸŸ¥ 4. Why the word **extends** is used?

Because TypeScript checks **assignability**, not inheritance.

`T extends U` means:

> "Can a value of type T be assigned to a variable of type U?"

Example:

* A number **cannot** be assigned to a string â†’ âŒ
* A string literal `"hello"` **can** be assigned to `string` â†’ âœ”

So conditional types work based on â€œis assignable toâ€.

---

# ğŸŸ¦ 5. Key Concept â€” It Works on Types, NOT Values

This is **type-level programming**.

We are not checking runtime values.

We are checking **types themselves**.

---

# ğŸŸ¨ 6. Real Example: Extract Array Element Type

```ts
type Element<T> = T extends (infer U)[] ? U : T;
```

Explanation:

* `infer U` = â€œTypeScript, please figure out this type and store it in Uâ€
* If `T` is an array â†’ return the element type
* Otherwise â†’ return T

Usage:

```ts
type A = Element<string[]>; // string
type B = Element<number[]>; // number
type C = Element<boolean>;  // boolean (not an array)
```

---

# ğŸŸª 7. Another Example: Extract Return Type of Function

```ts
type MyReturn<T> =
  T extends (...args: any[]) => infer R ? R : never;
```

Usage:

```ts
type R = MyReturn<() => number>;   // number
type S = MyReturn<(a: string) => boolean>; // boolean
```

---

# ğŸ‰ 8. Summary â€” What You Saw Was:

### âœ” A conditional type

```ts
T extends U ? X : Y
```

### âœ” Checks type relationship

* If T can be assigned to U
* Then choose `X`
* Else choose `Y`

### âœ” Used for advanced type logic

* Extract types
* Compare types
* Transform types
* Build utility types



---
---


# âœ… Your Code

```ts
type NotNull<T> = T extends null ? never : T;

type Result = NotNull<string | null>;
```

Youâ€™re seeing a **conditional type** + **union distribution** â€” two powerful TypeScript features.

---

# â­ Step 1: What is a Conditional Type?

Syntax:

```ts
T extends U ? X : Y
```

Meaning:

* If **T is assignable to U**, result becomes **X**
* Else, result becomes **Y**

Example:

```ts
type IsString<T> = T extends string ? true : false;

IsString<string>  // true
IsString<number>  // false
```

---

# â­ Step 2: Union Distribution (VERY IMPORTANT)

When you apply a conditional type to a union:

```ts
NotNull<string | null>
```

TypeScript **splits the union** and checks each member separately.

So it becomes:

```
NotNull<string> | NotNull<null>
```

Which becomes:

```
(string extends null ? never : string) |
(null extends null ? never : null)
```

Now evaluate each:

### âœ” `string extends null ? never : string`

* `string` **is not assignable to** `null`
* Result â†’ **string**

### âœ” `null extends null ? never : null`

* `null` **is assignable to** `null`
* Result â†’ **never**

So final:

```
string | never  â  string
```

---

# ğŸ‰ Final Result

```ts
type Result = string;
```

---

# ğŸ§  What does `NotNull` do?

It removes **null** from a union:

| Input Type | Output  |            |         |            |
| ---------- | ------- | ---------- | ------- | ---------- |
| `string    | null`   | `string`   |         |            |
| `number    | null    | undefined` | `number | undefined` |
| `null`     | `never` |            |         |            |
| `Person    | null`   | `Person`   |         |            |

Itâ€™s basically a custom version of **NonNullable<T>** built into TypeScript.

---

# âœ… Why This Syntax Is Powerful

You can build reusable type tools:

### Example: Remove `undefined` too:

```ts
type NotNullish<T> = T extends null | undefined ? never : T;
```

### Example: Keep only functions:

```ts
type OnlyFunctions<T> = T extends (...args: any)=>any ? T : never;
```

### Example: Extract only string properties:

```ts
type StringProps<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K];
};
```

This is the foundation of advanced TypeScript typing.


---
---
---


# â­ What is `never`?

`never` means:

> **A value that can NEVER exist.**

It represents **impossible**, **unreachable**, or **no value at all**.

---

# â­ Where is `never` used?

## 1ï¸âƒ£ **Conditional types that filter things out**

Example:

```ts
type NotNull<T> = T extends null ? never : T;
```

If T = null
â†’ we return `never`
â†’ meaning â€œremove itâ€.

This is how TypeScript removes types from unions.

Example:

```ts
type A = string | null;
type B = NotNull<A>;   // string
```

Because:

```
NotNull<string> = string
NotNull<null>   = never
```

Union:

```
string | never   â string
```

---

## 2ï¸âƒ£ **A function that never returns**

Example:

```ts
function fail(msg: string): never {
  throw new Error(msg);
}
```

This function does **not** return *anything*, ever.
It either crashes or loops forever.

---

## 3ï¸âƒ£ **A function that never reaches end**

Example:

```ts
function infiniteLoop(): never {
  while (true) {}
}
```

Since it cannot finish â†’ return type is `never`.

---

## 4ï¸âƒ£ **Impossible code paths**

```ts
type Shape = "circle" | "square";

function area(shape: Shape) {
  if (shape === "circle") {
      // ...
  } else if (shape === "square") {
      // ...
  } else {
      // shape is never here!
      const impossible: never = shape;
  }
}
```

The else block is unreachable â†’ `shape` becomes `never`.

---

# â­ Why does `never` disappear in unions?

Because `never` means â€œno valueâ€.

Example:

```ts
type X = string | never   // string
type Y = number | never   // number
type Z = never | never    // never
```

`never` acts like **0 in addition**:

```
something + 0 = something
```

So:

```
T | never = T
```

---

# â­ Summary (in one line)

`never` is used to represent **no value**, **impossible value**, or a type that gets **filtered out** during conditional types.


---
---
---



You want a **visual, simple, step-by-step code example** that shows exactly **what TypeScript does** when:

* conditional type runs
* union splits
* `never` appears
* `never` disappears
* final result forms

So here is the **cleanest possible visualization**.

---

# âœ… **1. Write the conditional type**

```ts
type NotNull<T> = T extends null ? never : T;
```

---

# âœ… **2. Give it a union**

```ts
type Input = string | null | number;
type Output = NotNull<Input>;
```

---

# â­ **3. VISUALIZATION â€” This is what TypeScript does**

### It *splits the union*:

```
NotNull<string> 
| NotNull<null> 
| NotNull<number>
```

### Now evaluate each one:

### âœ” Case 1: `NotNull<string>`

```
string extends null ? never : string
result â†’ string
```

---

### âœ” Case 2: `NotNull<null>`

```
null extends null ? never : null
result â†’ never
```

---

### âœ” Case 3: `NotNull<number>`

```
number extends null ? never : number
result â†’ number
```

---

# â­ **4. Combine the results again**

```
string | never | number
```

And because `never` means â€œno value,â€ it disappears:

```
string | number
```

---

# ğŸ‰ **FINAL RESULT**

```ts
type Output = string | number;
```

---

# â­ FULL VISUALIZED CODE (cleanest version)

```ts
type NotNull<T> = T extends null ? never : T;

type Input = string | null | number;

// Step-by-step visualization:
//
// NotNull<string> â†’ string
// NotNull<null>   â†’ never
// NotNull<number> â†’ number
//
// Combined: string | never | number
// After removing never: string | number

type Output = NotNull<Input>;  // string | number
```

---

# ğŸ§± Another Visualization Example (Extracting Only Numbers)

```ts
type OnlyNumber<T> = T extends number ? T : never;

type Mixed = string | number | boolean | number;

// Visualization:
//
// OnlyNumber<string>  â†’ never
// OnlyNumber<number>  â†’ number
// OnlyNumber<boolean> â†’ never
// OnlyNumber<number>  â†’ number
//
// Combined: never | number | never | number
// Collapse: number
```

Result:

```ts
type Result = OnlyNumber<Mixed>; // number
```



---
---
---




# ğŸš€ The Code

```ts
type ReturnTypeOf<T> =
  T extends (...args: any[]) => infer R ? R : never;
```

You are confused because of **`infer R`**.
This is the part that feels like magic.

Letâ€™s decode it LIKE A HUMAN, not like documentation.

---

# âœ… Step 1: Recognize the Pattern

This is a **conditional type**:

```
A extends B ? X : Y
```

Same structure as:

```ts
T extends something ? do this : do that
```

---

# âœ… Step 2: What is it checking?

```ts
T extends (...args: any[]) => infer R
```

This means:

> â€œIs T a **function type**?â€
> â€œIf yes, extract its **return type** and call it Râ€

---

# âš¡ What is `infer R`?

`infer` allows TypeScript to **capture** a type from inside another type.

Think of it like:

> â€œInside this function type, please *pull out* whatever the return type is and store it in `R`.â€

Example:

If `T = () => number`

Then:

* `infer R` becomes **number**
* So the whole type returns **number**

---

# ğŸ§  Step-by-step Visualization

## Example:

```ts
type A = ReturnTypeOf<() => string>;
```

Letâ€™s apply your rule manually:

### 1ï¸âƒ£ Does `T` match this pattern?

```
(...args: any[]) => infer R
```

Our T = `() => string`, so:

```
() => string extends (...args: any[]) => infer R
```

Yes, both are functions.

### 2ï¸âƒ£ Extract R

Whatever return value is â†’ **string**

So R = string

### 3ï¸âƒ£ Return it:

```
ReturnTypeOf<T> = R = string
```

---

# ğŸ‰ Final Result

```ts
type A = string;
```

---

# ğŸ”¥ Another Example (More clear)

```ts
type B = ReturnTypeOf<(x: number) => boolean>;
```

Check:

```
(x: number) => boolean
extends
(...args: any[]) => infer R
```

Yes.

So R = boolean.

Result:

```ts
type B = boolean;
```

---

# ğŸ§© What if T is NOT a function?

```ts
type C = ReturnTypeOf<string>;
```

Check:

```
string extends (...args: any[]) => infer R
```

No, string is NOT a function.

So:

```
ReturnTypeOf<string> = never
```

---

# â­ Summary in One Line

> **infer R** lets TypeScript extract the return type of a function inside a conditional type.

This is how TypeScript internally implements the built-in:

```ts
type ReturnType<T>
```

Your custom type is literally the same thing.
