# 🔹 First Code (your original)

```js
const file = require('fs');

file.readFile("01_after_trim.txt", "utf-8", (err, content) => {
    if (content !== null) {
        file.truncate("01_after_trim.txt", 0, (err) => {
            if (err) throw err
        })
    }
    file.readFile("01_initial.txt", "utf-8", (err, content) => {
        data = content.trim()
        file.writeFile("01_after_trim.txt", `${data}`, () => {
            console.log('done')
        })
    })
})
```

### ✅ What it does

1. Opens **`01_after_trim.txt`** and clears it (truncate = set file size to 0).
2. Opens **`01_initial.txt`**, trims leading/trailing spaces.
3. Writes the trimmed content into **`01_after_trim.txt`**.
4. Prints `"done"`.

### ⚠️ Issues

* **Unnecessary truncate**: You don’t need to empty the file before writing, because `writeFile` already overwrites by default.
* **Nested callbacks**: Harder to read, leads to “callback hell”.
* **Coupled files**: Reads from one file (`01_initial.txt`) but bases logic on another (`01_after_trim.txt`) → not clean separation.

👉 In short: it **clears one file and fills it with trimmed content from another file**, but in a messy way.

---

# 🔹 Second Code (better way)

```js
const fs = require("fs");

function cleanFile(initialFilePath, trimmedFilePath) {
    return new Promise(resolve => {
        fs.readFile(initialFilePath, "utf-8", (err, data) => {
            data = data.trim();
            fs.writeFile(trimmedFilePath, data, () => {
                resolve();
            });
        });
    });
}

async function main() {
    await cleanFile("02_initial.txt", "02_after_trim.txt");
    console.log("Done cleaning file");
}

main();
```

### ✅ What it does

1. `cleanFile` is a reusable function:

   * Reads `initialFilePath`.
   * Trims spaces.
   * Writes result to `trimmedFilePath`.
2. Returns a **Promise** (so you can use `await`).
3. `main` calls `cleanFile("02_initial.txt", "02_after_trim.txt")`.
4. Logs `"Done cleaning file"` after writing is complete.

### 🚀 Improvements

* **No truncate**: `writeFile` already overwrites, so simpler.
* **Promise + async/await**: Much cleaner than nested callbacks.
* **Reusable**: You can call `cleanFile` with *any* file paths.
* **Separation of concerns**: Reads from one file and writes to another in a clear, logical way.

---

# 🔹 Difference Between the Two

| Feature         | First Code                                             | Second Code                               |
| --------------- | ------------------------------------------------------ | ----------------------------------------- |
| File clearing   | Explicitly truncates `01_after_trim.txt` (unnecessary) | Skips truncate (simpler)                  |
| Style           | Nested callbacks (harder to maintain)                  | Async/await with Promises (cleaner)       |
| Reusability     | Hardcoded file names                                   | Function accepts file paths as parameters |
| Logic           | Reads one file, trims another → confusing              | Straightforward: input → trim → output    |
| Error handling  | Missing (ignores `err` in some places)                 | Could add try/catch easily                |
| Maintainability | Messy and brittle                                      | Modular and clean                         |

---

# 🔹 In Short

* **First code**: Clears one file, copies trimmed content from another → messy, redundant, and hard to read.
* **Second code**: Clean, modular, and uses modern async patterns → much better for real projects.
