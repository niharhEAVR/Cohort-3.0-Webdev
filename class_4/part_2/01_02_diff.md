# ðŸ”¹ First Code (your original)

```js
const file = require('fs');

file.readFile("01_after_trim.txt", "utf-8", (err, content) => {
    if (content !== null) {
        file.truncate("01_after_trim.txt", 0, (err) => {
            if (err) throw err
        })
    }
    file.readFile("01_initial.txt", "utf-8", (err, content) => {
        data = content.trim()
        file.writeFile("01_after_trim.txt", `${data}`, () => {
            console.log('done')
        })
    })
})
```

### âœ… What it does

1. Opens **`01_after_trim.txt`** and clears it (truncate = set file size to 0).
2. Opens **`01_initial.txt`**, trims leading/trailing spaces.
3. Writes the trimmed content into **`01_after_trim.txt`**.
4. Prints `"done"`.

### âš ï¸ Issues

* **Unnecessary truncate**: You donâ€™t need to empty the file before writing, because `writeFile` already overwrites by default.
* **Nested callbacks**: Harder to read, leads to â€œcallback hellâ€.
* **Coupled files**: Reads from one file (`01_initial.txt`) but bases logic on another (`01_after_trim.txt`) â†’ not clean separation.

ðŸ‘‰ In short: it **clears one file and fills it with trimmed content from another file**, but in a messy way.

---

# ðŸ”¹ Second Code (better way)

```js
const fs = require("fs");

function cleanFile(initialFilePath, trimmedFilePath) {
    return new Promise(resolve => {
        fs.readFile(initialFilePath, "utf-8", (err, data) => {
            data = data.trim();
            fs.writeFile(trimmedFilePath, data, () => {
                resolve();
            });
        });
    });
}

async function main() {
    await cleanFile("02_initial.txt", "02_after_trim.txt");
    console.log("Done cleaning file");
}

main();
```

### âœ… What it does

1. `cleanFile` is a reusable function:

   * Reads `initialFilePath`.
   * Trims spaces.
   * Writes result to `trimmedFilePath`.
2. Returns a **Promise** (so you can use `await`).
3. `main` calls `cleanFile("02_initial.txt", "02_after_trim.txt")`.
4. Logs `"Done cleaning file"` after writing is complete.

### ðŸš€ Improvements

* **No truncate**: `writeFile` already overwrites, so simpler.
* **Promise + async/await**: Much cleaner than nested callbacks.
* **Reusable**: You can call `cleanFile` with *any* file paths.
* **Separation of concerns**: Reads from one file and writes to another in a clear, logical way.

---

# ðŸ”¹ Difference Between the Two

| Feature         | First Code                                             | Second Code                               |
| --------------- | ------------------------------------------------------ | ----------------------------------------- |
| File clearing   | Explicitly truncates `01_after_trim.txt` (unnecessary) | Skips truncate (simpler)                  |
| Style           | Nested callbacks (harder to maintain)                  | Async/await with Promises (cleaner)       |
| Reusability     | Hardcoded file names                                   | Function accepts file paths as parameters |
| Logic           | Reads one file, trims another â†’ confusing              | Straightforward: input â†’ trim â†’ output    |
| Error handling  | Missing (ignores `err` in some places)                 | Could add try/catch easily                |
| Maintainability | Messy and brittle                                      | Modular and clean                         |

---

# ðŸ”¹ In Short

* **First code**: Clears one file, copies trimmed content from another â†’ messy, redundant, and hard to read.
* **Second code**: Clean, modular, and uses modern async patterns â†’ much better for real projects.
